// Copyright Â© 2018 ijon <segfaultsamurai@gmail.com>
// This work is free. You can redistribute it and/or modify it under the
// terms of the Do What The Fuck You Want To Public License, Version 2,
// as published by Sam Hocevar. See the LICENSE.txt file for more details.


class QuakeAccelPlayer: PlayerPawn
{
    enum QuakeMoveFlags
    {
        QMF_FLYING       = 0x1,
        QMF_FLAWEDXY     = 0x2,
        QMF_IGNOREJUMP   = 0x4,
        QMF_IGNORECROUCH = 0x8,
    };
    
    const MAXMOVE                = 0x3200;        // purely for scaling the movement commands
    const DEFAULT_FRICTION       = 0.90625;       // default friction, used for scaling our friction
    const DEFAULT_MOVEMULT       = 0.03125;       // default movement speed mult, also used for friction scaling
    const MORE_FRICTION_VELOCITY = 15000.0/65536; // to unfuck the movement scaling on high friction floors
    const MAXSLOPEPITCH          = 45;            // Slopes at or above this pitch won't get jumped up
    // interal vars

    protected bool    Q_Enabled;             // if off, use regular movement
    protected bool    Q_BlockJump;           // set when you jump, cleared when you let go of jump
    protected bool    Q_BlockSlide;          // set when you jump, cleared when you let go of crouch
    protected uint    Q_CrouchSlideHeldTime; // how many tics you've held crouch
    protected int     Q_GroundTime;          // positive = tics spent on ground, negative = tics spent off ground
    protected int     Q_FallTime;            // time spent off ground with negative Z velocity
    protected int     Q_WaterTime;           // positive = tics spent with waterlevel > 1, negative = tics spent with waterlevel <= 1
    protected vector3 Q_LastVel;

    // Q_BlockJump is only set if Q_Autohop is off
    // Q_BlockSlide is only set if Q_EasyCrouchSlide is off
    // Q_CrouchSlideHeldTime won't count down in midair if Q_AutoSlide is on
    // Q_FallTime resets when you next leave the ground

    // exposed vars

    bool   Q_UseQuakeAccel;    // self explanatory

    double Q_GroundSpeed;      // how much speed (u/s**2) you gain in
    double Q_CrouchSpeed;      // a second when moving 100% in one direction,
    double Q_AirSpeed;         // ignoring friction and speed caps
    double Q_FlySpeed;
    double Q_WaterSpeed;
    double Q_CSlideSpeed;

    double Q_MaxGroundSpeed;   // acceleration "speed cap" (u/s) - it
    double Q_MaxCrouchSpeed;   // only checks your velocity in the direction
    double Q_MaxAirSpeed;      // you're accelerating, hence strafejumping
    double Q_MaxFlySpeed;      //
    double Q_MaxWaterSpeed;    // max speed values below 0 mean "no speed cap"
    double Q_MaxCSlideSpeed;

    double Q_GroundFriction;   // how many seconds it takes for your velocity to
    double Q_CrouchFriction;   // be reduced to half its current value - engine
    double Q_AirFriction;      // friction is zeroed out to allow for ours
    double Q_FlyFriction;      // 
    double Q_WaterFriction;    // friction value below 0 means "no friction"
    double Q_CSlideFriction;

    double Q_StopGroundSpeed;  // if your speed (u/s) is below this value, the
    double Q_StopCrouchSpeed;  // friction formula acts like your speed is this
    double Q_StopAirSpeed;     // when determining how much to lower your velocity
    double Q_StopFlySpeed;
    double Q_StopWaterSpeed;
    double Q_StopCSlideSpeed;

    double Q_Gravity;               // gravity value when using quake accel
    double Q_JumpHeight;            // jump height to use when using quake accel
    double Q_MidairStepHeight;      // your MaxStepHeight when in midair
    double Q_DoubleJumpFactor;      // add portion of jump height to Z velocity on jump, rather than just set
    double Q_RampJumpFactor;        // Controls how much a ramp's slope can affect your jump height
    uint   Q_CrouchSlideTime;       // minimum amount of tics you can slide for after hitting the ground
    double Q_CrouchSlideTimeScale;  // your fall time is multiplied by this and added to Q_CrouchSlideTime
    uint   Q_CrouchSlideTimeMax;    // does exactly what it says it does (it's in tics)
    double Q_WadingSpeedScale;      // scales your speed when waterlevel = 1

    bool   Q_EasyCrouchSlide;  // slide time doesn't tick down if you hold crouch in midair
    bool   Q_Autohop;          // you don't need to let go of jump to repeatedly jump
    bool   Q_AutoSlide;        // you don't need to let go of crouch to repeatedly slide
    bool   Q_FlawedAirMove;    // replicate quake 3 behavior where holding jump midair slows horizontal movement
    bool   Q_VQ1Bunnyhop;      // ground friction applies for a tic, even if you hop immediately
    bool   Q_MagneticLedges;   // when enabled, your friction is doubled if you're about to walk off a ledge
    bool   Q_InstantZAdjust;   // when swimming, jump and crouch instantly make you rise/fall at set speeds
    bool   Q_Q2SurfaceTension; // when swimming on the surface (waterlevel 1), Z velocity maxes out at 0

    property UseQuakeAccel:   Q_UseQuakeAccel;

    property GroundSpeed:     Q_GroundSpeed;
    property CrouchSpeed:     Q_CrouchSpeed;
    property AirSpeed:        Q_AirSpeed;
    property FlySpeed:        Q_FlySpeed;
    property WaterSpeed:      Q_WaterSpeed;
    property CSlideSpeed:     Q_CSlideSpeed;

    property MaxGroundSpeed:  Q_MaxGroundSpeed;
    property MaxCrouchSpeed:  Q_MaxCrouchSpeed;
    property MaxAirSpeed:     Q_MaxAirSpeed;
    property MaxFlySpeed:     Q_MaxFlySpeed;
    property MaxWaterSpeed:   Q_MaxWaterSpeed;
    property MaxCSlideSpeed:  Q_MaxCSlideSpeed;

    property GroundFriction:  Q_GroundFriction;
    property CrouchFriction:  Q_CrouchFriction;
    property AirFriction:     Q_AirFriction;
    property FlyFriction:     Q_FlyFriction;
    property WaterFriction:   Q_WaterFriction;
    property CSlideFriction:  Q_CSlideFriction;

    property StopGroundSpeed: Q_StopGroundSpeed;
    property StopCrouchSpeed: Q_StopCrouchSpeed;
    property StopAirSpeed:    Q_StopAirSpeed;
    property StopFlySpeed:    Q_StopFlySpeed;
    property StopWaterSpeed:  Q_StopWaterSpeed;
    property StopCSlideSpeed: Q_StopCSlideSpeed;

    property QGravity:              Q_Gravity;
    property QJumpHeight:           Q_JumpHeight;
    property MidairStepHeight:      Q_MidairStepHeight;
    property DoubleJumpFactor:      Q_DoubleJumpFactor;
    property RampJumpFactor:        Q_RampJumpFactor;
    property CrouchSlideTime:       Q_CrouchSlideTime;
    property CrouchSlideTimeScale:  Q_CrouchSlideTimeScale;
    property CrouchSlideTimeMax:    Q_CrouchSlideTimeMax;
    property WadingSpeedScale:      Q_WadingSpeedScale;

    property Autohop:          Q_Autohop;
    property AutoSlide:        Q_AutoSlide;
    property VQ1Bunnyhop:      Q_VQ1Bunnyhop;
    property EasyCrouchSlide:  Q_EasyCrouchSlide;
    property FlawedAirMove:    Q_FlawedAirMove;
    property MagneticLedges:   Q_MagneticLedges;
    property InstantZAdjust:   Q_InstantZAdjust;
    property Q2SurfaceTension: Q_Q2SurfaceTension;

    Default
    {
        QuakeAccelPlayer.UseQuakeAccel   true;

        // the crouchslide values are based off of quake 4 @ 60 fps
        // if you want slash sliding as of october, double the speed values
        //  (quake 4 is largely locked at 60fps, tho q4max duels run at 90fps)
        //
        // the rest of them are based off of quake 1 @ 77 fps
        //  (quakeworld servers typically run at 77fps)
        //
        // if you're porting values from other games with quake movement, here's a
        //  python function to help you port the friction values
        //
        // halftime = lambda friction, ticrate: math.log(0.5, 1-(friction/ticrate))/ticrate
        //
        // some quake -> halftime friction values:
        //
        //      60 FPS    72 FPS    77 FPS    85 FPS    125 FPS
        //  1: 0.687355  0.688322  0.688636  0.689062  0.690371
        //  2: 0.340765  0.341737  0.342053  0.342480  0.343794
        //  3: 0.225223  0.226201  0.226518  0.226947  0.228265
        //  4: 0.167444  0.168427  0.168746  0.169177  0.170499
        //  5: 0.132769  0.133758  0.134078  0.134511  0.135838
        //  6: 0.109647  0.110641  0.110963  0.111397  0.112729
        
        // values come from the first quake game you could use the movement in,
        //  with the exception of water speeds, which are half of quake 1's speeds
        //  to better match regular zdoom swim speeds

        QuakeAccelPlayer.GroundSpeed     4400;  // base accel
        QuakeAccelPlayer.CrouchSpeed     1375;  // 5/16 of base accel (q2)
        QuakeAccelPlayer.AirSpeed        4400;  // same as base accel (q1)
        QuakeAccelPlayer.FlySpeed        3520;  // 4/5  of base accel (q3)
        QuakeAccelPlayer.WaterSpeed      2200;  // 1/2  of base accel (q1, but halved)
        QuakeAccelPlayer.CSlideSpeed     2200;  // 1/2  of base accel (q4)

        QuakeAccelPlayer.MaxGroundSpeed  440;   // base speed
        QuakeAccelPlayer.MaxCrouchSpeed  137.5; // 5/16 of base speed (q2)
        QuakeAccelPlayer.MaxAirSpeed     41.25; // same as base speed (q1)
        QuakeAccelPlayer.MaxFlySpeed     440;   // 4/5  of base speed (q3)
        QuakeAccelPlayer.MaxWaterSpeed   220;   // 1/2  of base speed (q1, but halved)
        QuakeAccelPlayer.MaxCSlideSpeed  220;   // 1/2  of base speed (q4)

        QuakeAccelPlayer.GroundFriction  0.168746; // 4 @ 77fps  (q1)
        QuakeAccelPlayer.CrouchFriction  0.111397; // 6 @ 85fps  (q2)
        QuakeAccelPlayer.AirFriction     -1;
        QuakeAccelPlayer.FlyFriction     0.228265; // 3 @ 125fps (q3)
        QuakeAccelPlayer.WaterFriction   0.168746; // 4 @ 77fps  (q1)
        QuakeAccelPlayer.CSlideFriction  0.687355; // 1 @ 60fps  (q4)

        QuakeAccelPlayer.StopGroundSpeed 137.5; // 5/16 of base speed (all games)
        QuakeAccelPlayer.StopCrouchSpeed 137.5;
        QuakeAccelPlayer.StopAirSpeed    0;
        QuakeAccelPlayer.StopFlySpeed    137.5;
        QuakeAccelPlayer.StopWaterSpeed  137.5;
        QuakeAccelPlayer.StopCSlideSpeed 137.5;

        QuakeAccelPlayer.QGravity               0.65;
        QuakeAccelPlayer.QJumpHeight            40;
        QuakeAccelPlayer.MidairStepHeight       0;
        QuakeAccelPlayer.DoubleJumpFactor       1;
        QuakeAccelPlayer.RampJumpFactor         0.707;
        QuakeAccelPlayer.CrouchSlideTime        0;
        QuakeAccelPlayer.CrouchSlideTimeScale   0;
        QuakeAccelPlayer.CrouchSlideTimeMax     0;
        QuakeAccelPlayer.WadingSpeedScale       0.666; // for parity with regular doomguy

        QuakeAccelPlayer.Autohop           false;
        QuakeAccelPlayer.AutoSlide         false;
        QuakeAccelPlayer.VQ1Bunnyhop       false;
        QuakeAccelPlayer.EasyCrouchSlide   false;
        QuakeAccelPlayer.FlawedAirMove     false;
        QuakeAccelPlayer.MagneticLedges    false;
        QuakeAccelPlayer.InstantZAdjust    true;
    }
    
    
    // this is here mostly to remind myself how I got these functions
    //
    // friction: endSpeed = startSpeed * (1 - (qfriction * frametime))  (how quake does it)
    //   or:     endSpeed = startSpeed * (1 - (qfriction / ticrate))
    //
    // so friction = qfriction / ticrate
    //
    // quake's friction values get plugged directly into that, but we use halftimes,
    //  so some math is needed
    // 
    // (1 - friction) ** (halftime * ticrate) = 0.5
    //  1 - friction =   0.5 ** (1 / (halftime * ticrate))
    //    - friction =   0.5 ** (1 / (halftime * ticrate))  - 1
    //      friction = -(0.5 ** (1 / (halftime * ticrate))) + 1
    //
    // to get halftime from a friction value and ticrate:
    //
    // (1 - friction) ** (halftime * ticrate) = 0.5     // a ** b = c
    // halftime * ticrate = log[1 - friction](0.5)      // log[a](c) = b
    // halftime = log[1 - friction](0.5) / ticrate
    
    
    static clearscope double QA_HalftimeToFriction(double halftime, int fps)
    {
        return -(0.5 ** (1 / (halftime * fps))) + 1;
    }
    
    static clearscope double QA_FrictionToHalftime(double friction, int fps)
    {
        return log(0.5) / (log(1 - friction) * fps);
    }
    
    static clearscope double QA_HalftimeToQFriction(double halftime, int fps)
    {
        return QA_HalftimeToFriction(halftime, fps) * fps;
    }
    
    static clearscope double QA_QFrictionToHalftime(double qfriction, int fps)
    {
        return QA_FrictionToHalftime(qfriction / fps, fps);
    }


    static clearscope double QA_Turbo()
    {
        return CVar.FindCVar("turbo").GetFloat() / 100;
    }


    static clearscope vector3 QA_Rotate3D(vector3 vec, double yaw, double pitch)
    {
        // x' =  cos(angle) cos(pitch)x + -sin(angle)y + cos(angle) sin(pitch)z
        // y' =  sin(angle) cos(pitch)x +  cos(angle)y + sin(angle) sin(pitch)z
        // z' =            -sin(pitch)x                +            cos(pitch)z

        vector3 ret;

        ret.x = (vec.x * cos(yaw) * cos(pitch))
              - (vec.y * sin(yaw))
              + (vec.z * cos(yaw) * sin(pitch));

        ret.y = (vec.x * sin(yaw) * cos(pitch))
              + (vec.y * cos(yaw))
              + (vec.z * sin(yaw) * sin(pitch));

        ret.z = -(vec.x * sin(pitch))
              +  (vec.z * cos(pitch));

        return ret;
    }


    static void QA_NormalizeMoveCmd(UserCmd cmd)
    {
        // Make walk speed 50% of run speed even when strafing (or try to, anyway -
        //  there's no way of telling whether an analog stick is walking at <= 100%
        //  or running at <= 60%)

        // Movement commands are left shifted 8 bits before being sent to ZScript
        if (abs(cmd.sidemove) < (uint(0x28 * QA_Turbo()) << 8))
        {
            cmd.sidemove = (cmd.sidemove * 25) / 24;
        }
        else
        {
            cmd.sidemove = (cmd.sidemove * 5) / 4;
        }

        // throw jump and crouch into here, and loosely guess at whether the player
        //  is walking or running
        int maxXYmove = max(abs(cmd.forwardmove), abs(cmd.sidemove));

        cmd.upmove = (cmd.upmove * MAXMOVE) / 0x300;

        cmd.upmove = clamp(cmd.upmove, -MAXMOVE, MAXMOVE);
    }


    static clearscope vector3, double QA_GetMoveDir(UserCmd cmd, double angle, double pitch, int flags = 0)
    {
        vector3 movedir;

        if (flags & QMF_FLYING)
        {
            movedir = QA_Rotate3D((cmd.forwardmove, -cmd.sidemove, 0), angle, pitch);
            if (abs(cmd.upmove) >= (MAXMOVE / 4)) { movedir.z = cmd.upmove; }
            
            if (!(flags & QMF_IGNOREJUMP)   && cmd.buttons & BT_JUMP)   { movedir.z += 12800; }
            if (!(flags & QMF_IGNORECROUCH) && cmd.buttons & BT_CROUCH) { movedir.z -= 12800; }
        }
        else
        {
            vector2 movedir_xy = RotateVector((cmd.forwardmove, -cmd.sidemove), angle);
            movedir = (movedir_xy.x, movedir_xy.y, (flags & QMF_FLAWEDXY) ? cmd.upmove : 0);
        }

        movedir /= (MAXMOVE * QA_Turbo());

        double movelength = movedir.length();
        if (movelength == 0) { return (0, 0, 0), 0; }

        double movescalar = 1;

        if (flags & QMF_FLAWEDXY)
        {
            movedir.z  = 0;
            movescalar = movedir.length() / movelength;
            movelength = movedir.length();

            if (movelength == 0) { return (0, 0, 0), 0; }
        }

        movelength = min(movelength, 1) * movescalar;
        return movedir.unit(), movelength;
    }
    
    
    bool QA_CheckDropoff()
    {
        // if we're standing on a thing, don't even bother, it'll just act weird
        if (z > floorz) { return false; }
        
        double thresholdFloorZ = floorz;
        double lowestFloorZ    = floorz;
        
        if (vel.xy.length() > 0)
        {
            for (int i = 0; i < 4; i++)
            {
                FCheckPosition checkResult;
                vector2 newpos = pos.xy + (vel.xy.unit() * 8 * i);
                CheckMove(newpos, PCM_NOACTORS, checkResult);
                
                double checkZ = checkResult.floorz;
                
                if (checkZ > floorz + MaxStepHeight) { break; }
                if (checkZ > thresholdFloorZ) { thresholdFloorZ = checkZ; }
                lowestFloorZ = min(lowestFloorZ, checkResult.floorz);
            }
        }
        
        return lowestFloorZ < thresholdFloorZ;
    }


    void QA_SetEnabled(bool on)
    {
        // voodoo doll check
        if (!self.player || self.player.mo != self) { return; }

        Q_Enabled         = on;
        Gravity           = on ? Q_Gravity : Default.Gravity;
        JumpZ             = on ? sqrt(2 * Q_JumpHeight * Q_Gravity) : Default.JumpZ;
        bNoFriction       = on ? true : Default.bNoFriction;
        bNoFrictionBounce = on ? true : Default.bNoFrictionBounce;

        // to avoid any issues with turning quake accel off in midair
        if (!on) { MaxStepHeight = Default.MaxStepHeight; }
    }


    override void Tick()
    {
        if (Q_Enabled != Q_UseQuakeAccel) { QA_SetEnabled(Q_UseQuakeAccel); }
        Super.Tick();
    }


    void Bob(vector2 addVel)
    {
        player.Vel += addVel;
    }
    
    void SetBob(vector2 vel)
    {
        player.Vel = vel;
    }

    void ReduceBob(double bobFactor)
    {
        player.Vel *= bobFactor;
    }
    
    
    // Override to make (un)crouching faster
    override void CheckCrouch(bool totallyfrozen)
    {
        if (!Q_Enabled) { Super.CheckCrouch(totallyfrozen); return; }

        let player = self.player;
        UserCmd cmd = player.cmd;

        if (CanCrouch() && player.health > 0 && level.IsCrouchingAllowed())
        {
            if (!totallyfrozen)
            {
                int crouchdir = (cmd.buttons & BT_CROUCH) && !(cmd.buttons & BT_JUMP) ? -1 : 1;
                
                if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
                {
                    CrouchMove(4);
                }
                else if (crouchdir == -1 && player.crouchfactor > 0.5)
                {
                    CrouchMove(-4);
                }
            }
        }
        else
        {
            player.Uncrouch();
        }

        player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
    }


    override void HandleMovement()
    {
        if (!Q_Enabled) { Super.HandleMovement(); return; }

        let player  = self.player;
        UserCmd cmd = player.cmd;

        // [RH] Check for fast turn around
        if (cmd.buttons & BT_TURN180 && !(player.oldbuttons & BT_TURN180))
        {
            player.turnticks = TURN180_TICKS;
        }

        bool wasOnGround = player.onground;
        player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);
        MaxStepHeight = (player.onground || waterlevel > 0) ? Default.MaxStepHeight : Q_MidairStepHeight;
        
        Q_GroundTime  = player.onground ? max(0, Q_GroundTime) + 1 : min(0, Q_GroundTime) - 1;
        Q_WaterTime   = waterlevel > 1  ? max(0, Q_WaterTime)  + 1 : min(0, Q_WaterTime)  - 1;

        if (Q_GroundTime < 0)
        {
            if (Q_GroundTime == -1) { Q_FallTime = 0; }
            Q_FallTime = vel.z > 0 ? 0 : Q_FallTime + 1;
        }

        QA_NormalizeMoveCmd(cmd);
        if (!(cmd.buttons & BT_JUMP))   { Q_BlockJump  = false; }
        if (!(cmd.buttons & BT_CROUCH)) { Q_BlockSlide = false; }

        QA_TurnPlayer();

        if (QA_CanFlyMove())
        {
            QA_FlyMove();
        }
        else
        {
            QA_GravityMove();
        }

        QA_SetRoll(cmd);

        if (reactiontime > 0) { reactiontime--; }
        Q_LastVel = vel;
    }


    override void DeathThink()
    {
        Super.DeathThink();

        if (Q_Enabled)
        {
            if (QA_CanFlyMove())
            {
                QA_Friction(Q_FlyFriction, Q_StopFlySpeed);
            }
            else if (player.onground)
            {
                QA_Friction(Q_GroundFriction, Q_StopGroundSpeed);
            }
            else
            {
                QA_Friction(Q_AirFriction, Q_StopAirSpeed);
            }
        }
    }


    bool QA_CanFlyMove()
    {
        return waterlevel || bNoGravity;
    }


    bool QA_IsCrouching(UserCmd cmd)
    {
        if (player.IsTotallyFrozen() || player.crouchfactor == -1) { return false; }
        int crouchdir = (cmd.buttons & BT_CROUCH) && CanCrouch() && level.IsCrouchingAllowed() ? -1 : 1;

        // wants to crouch
        if (crouchdir == -1) { return player.crouchfactor < 1; }

        // wants to uncrouch
        return player.crouchfactor <= 0.5;
    }


    double QA_GetSpeedBoosts()
    {
        double factor = Speed * QA_Turbo();

        if (!player.morphTics)
        {
            for(let it = Inv; it != null; it = it.Inv)
            {
                factor *= it.GetSpeedFactor ();
            }
        }

        return factor;
    }


    void QA_TurnPlayer()
    {
        let player = self.player;
        UserCmd cmd = player.cmd;

        // [RH] 180-degree turn overrides all other yaws
        if (player.turnticks > 0)
        {
            player.turnticks--;
            Angle += (180. / TURN180_TICKS);
        }
        else
        {
            Angle += cmd.yaw * (360./65536.);
        }
    }


    // Returns movement speed multiplier
    double QA_Friction(double halftime, double stopspeed, bool usez = false)
    {
        if (!usez)
        {
            double vz = vel.z;
            vel.z = 0;
            double ret = QA_Friction(halftime, stopspeed, true);
            vel.z = vz;
            return ret;
        }
        
        double normFriction, normSpeed;

        [normFriction, normSpeed] = GetFriction();
        
        double frictionMult = (1 - normFriction) / (1 - DEFAULT_FRICTION);
        double speedMult    = normSpeed          / DEFAULT_MOVEMULT;
        double speed        = vel.length();

        if (frictionMult > 1)
        {
            // unfuck the speed multiplier
            if      (speed <= MORE_FRICTION_VELOCITY)     { speedMult *= 8; }
            else if (speed <= MORE_FRICTION_VELOCITY * 2) { speedMult *= 4; }
            else if (speed <= MORE_FRICTION_VELOCITY * 4) { speedMult *= 2; }
        }
        
        // unfuck water level speed mult bullshit
        if (waterlevel > 0 && !player.onground) { speedMult *= 2; }

        if (halftime == 0) { vel = (0,0,0); }
        
        if (vel.length() == 0)
        {
            ReduceBob(0);
            PlayIdle();
            return speedMult;
        }

        if (halftime < 0)
        {
            return speedMult;
        }

        double friction = QA_HalftimeToFriction(halftime, TICRATE);

        double baseSpeed  = vel.length() * TICRATE;
        double startSpeed = baseSpeed > stopspeed ? baseSpeed : stopspeed;
        double dropSpeed  = startSpeed * (1 - (friction * frictionMult));

        double diffSpeed  = startSpeed - dropSpeed;
        double endSpeed   = max(0, vel.length() - (diffSpeed / TICRATE));

        if (endSpeed == 0)
        {
            PlayIdle();
            ReduceBob(0);
            vel = (0, 0, 0);
        }
        else
        {
            vector3 newvel = vel.unit() * endSpeed;
            ReduceBob(speed > 0 ? endSpeed / speed : 0);
            vel = newvel;
        }

        return speedMult;
    }


    vector3 QA_Accelerate(vector3 wishdir, double wishspeed, double maxspeed)
    {
        vector3 addVel;
        
        if (maxspeed < 0)
        {
            addVel = wishdir * (wishspeed / (TICRATE * TICRATE));
        }
        else
        {
            double projSpeed  = vel dot wishdir;
            double deltaSpeed = (maxspeed / TICRATE) - projSpeed;
            if (deltaSpeed <= 0) { return (0, 0, 0); }

            addVel = wishdir * min(wishspeed / (TICRATE * TICRATE), deltaSpeed);
        }

        vel += addVel;
        return addVel;
    }


    // Returns the normal of the floor you're standing on, or (0, 0, 1) in midair
    //  Also returns whether it's ok to jump or not

    vector3, bool QA_CheckIfJumpable(double maxPitch = double.max)
    {
        if (floorsector)
        {
            double fas_floorz;
            Sector fas_sector;

            [fas_floorz, fas_sector] = floorsector.NextLowestFloorAt(pos.x, pos.y, pos.z, FFCF_3DRESTRICT, MaxStepHeight);

            vector3 normal = fas_sector.floorplane.Normal;
            double floorPitch = atan2(normal.xy.length(), normal.z);

            if (pos.z <= fas_floorz)
            {
                return normal, floorPitch < maxPitch;
            }
        }

        return (0, 0, 1), player.onGround;
    }


    bool QA_CheckJump()
    {
        UserCmd cmd = player.cmd;

        if (player.onGround && (cmd.buttons & BT_JUMP) && !(cmd.buttons & BT_CROUCH) && level.IsJumpingAllowed() && !Q_BlockJump)
        {
            vector3 floornormal;
            bool canjump;

            [floornormal, canjump] = QA_CheckIfJumpable(MAXSLOPEPITCH);
            if (!canjump) { return false; }


            double jumpvelz = (JumpZ * 35) / TICRATE;
            double jumpfac  = 0;

            // [BC] If the player has the high jump power, double his jump velocity.
            // (actually, pick the best factors from all active items.)
            //
            // I would modify this to add the effective jump bonuses together,
            //  but that'd lead to serious jump height sequence breaks
            for (let p = Inv; p != null; p = p.Inv)
            {
                let pp = PowerHighJump(p);

                if (pp)
                {
                    double f = pp.Strength;
                    jumpfac = max(jumpfac, f);
                }
            }

            if (jumpfac > 0) { jumpvelz *= jumpfac; }

            vector3 startVel = vel;
            vector3 rampVel  = startvel;

            // Disgusting hack to get what our Z velocity should be
            // Breaks with teleporters, although I guess you could say it's
            //  kinda like portal jumping
            if (Q_GroundTime <= 1)
            {
                startVel.z = rampVel.z = Q_LastVel.z - GetGravity();
            }

            double speedFromFloor = startVel dot floornormal;
            vector3 fromFloorVel  = floornormal * speedFromFloor;
            vector3 alignedvel    = startVel - fromFloorVel;

            vector3 jumpvector = (0, 0, jumpvelz);

            // Going into floor and bunnyhopping, align jump to floor
            if (Q_GroundTime <= 1 && speedFromFloor < 0)
            {
                jumpvector = floornormal * jumpvelz;
            }

            if (speedFromFloor > 0) { rampVel = alignedvel + (fromFloorVel * Q_DoubleJumpFactor); }
            else                    { rampVel = alignedvel; }
            
            rampVel += jumpvector;

            // XY changes always apply to ramp jumps, but Z changes can be disabled
            vector3 noRampVel  = (vel.x, vel.y, jumpvelz + max(0, startvel.z * Q_DoubleJumpFactor));
            vector3 noRampDiff = rampVel - noRampVel;
            
            vector3 newVel  = noRampVel + (noRampDiff * Q_RampJumpFactor);
            vector3 velDiff = newvel - vel;
            Bob(velDiff.xy);
            vel = newVel;
            
            if (!Q_Autohop) { Q_BlockJump  = true; }
            if (!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }

            return true;
        }

        return false;
    }


    void QA_FlyMove()
    {
        UserCmd cmd = player.cmd;
        vector3 movedir = (0,0,0);
        double  movelength = 0;
        
        bool swimming  = waterlevel && !(bNoclip && bNoGravity);
        bool surfacing = swimming && waterlevel <= 1 && !bNoGravity;
        
        if (surfacing)
        {
            QA_GravityMove();
            
            if (Q_WaterTime == -1 && Q_Q2SurfaceTension)
            { 
                vel.z = min(0, vel.z - GetGravity());
            }
            else
            { 
                vel.z -= GetGravity();
            }
            
            return;
        }
        
        Q_CrouchSlideHeldTime = Q_CrouchSlideTime;
        
        if (reactiontime <= 0)
        {
            int flags = QMF_FLYING;
            if (swimming & Q_InstantZAdjust) { flags |= QMF_IGNOREJUMP | QMF_IGNORECROUCh; }
            
            [movedir, movelength] = QA_GetMoveDir(cmd, Angle, Pitch, flags);
        }

        double speedmult, wishspeed, maxspeed, friction;

        if (swimming)
        {
            double halftime = Q_WaterFriction;
            
            if (waterlevel < 3)
            {
                double friction = QA_HalftimeToFriction(halftime, TICRATE) * (waterlevel / 3.0);
                halftime = QA_FrictionToHalftime(friction, TICRATE);
            }
            
            friction  = QA_Friction(halftime, Q_StopWaterSpeed, true);
            wishspeed = Q_WaterSpeed;
            maxspeed  = Q_MaxWaterSpeed;
        }
        else
        {
            friction  = QA_Friction(Q_FlyFriction, Q_StopFlySpeed, true);
            wishspeed = Q_FlySpeed;
            maxspeed  = Q_MaxFlySpeed;
        }

        speedmult = QA_GetSpeedBoosts() * friction * movelength;
        // don't do crouch speed multiplier, it only makes sense on the ground

        vector3 accel = QA_Accelerate(movedir, wishspeed * speedmult, maxspeed * speedmult);
        Bob(accel.xy);

        if (!(player.cheats & CF_PREDICTING) && accel.length() > 0) { PlayRunning(); }
        
        if (reactiontime <= 0 && swimming && Q_InstantZAdjust)
        {
            int direction = 0;
            if (cmd.buttons & BT_JUMP) { direction++; }
            if (cmd.buttons & BT_CROUCH) { direction--; }
            
            if (direction)
            {
                vel.z = direction * JumpZ / 3;
                PlayRunning();
            }
        }
        
        // TODO: remove this when/if +DONTSINK gets added
        if (!(cmd.forwardmove || cmd.sidemove)) { cmd.forwardmove = 1; }
    }


    void QA_GravityMove()
    {
        UserCmd cmd = player.cmd;
        vector3 movedir = (0,0,0);
        double  movelength = 0;

        double friction, wishspeed, maxspeed;

        if (QA_IsCrouching(cmd) && (player.onGround || !Q_EasyCrouchSlide))
        {
            Q_CrouchSlideHeldTime++;
        }
        else if (player.onGround)
        {
            Q_CrouchSlideHeldTime = Q_CrouchSlideTime;
        }
        else
        {
            Q_CrouchSlideHeldTime = 0;
        }
        
        double dropoffFactor = (Q_MagneticLedges && QA_CheckDropoff()) ? 0.5 : 1;
        bool   jumped = QA_CheckJump();

        if (player.onground && (!jumped || Q_VQ1Bunnyhop))
        {
            if (reactiontime <= 0)
            {
                [movedir, movelength] = QA_GetMoveDir(cmd, Angle, Pitch);
            }
            
            int slideTimeLimit = Q_CrouchSlideTime + int(Q_FallTime * Q_CrouchSlideTimeScale);
            if (Q_CrouchSlideTimeMax > 0) { slideTimeLimit = min(slideTimeLimit, Q_CrouchSlideTimeMax); }

            if (QA_IsCrouching(cmd))
            {
                if (!Q_BlockSlide && Q_CrouchSlideHeldTime <= slideTimeLimit)
                {
                    friction  = QA_Friction(Q_CSlideFriction * dropoffFactor, Q_StopCSlideSpeed);
                    wishspeed = Q_CSlideSpeed;
                    maxspeed  = Q_MaxCSlideSpeed;
                }
                else
                {
                    friction  = QA_Friction(Q_CrouchFriction * dropoffFactor, Q_StopCrouchSpeed);
                    wishspeed = Q_CrouchSpeed;
                    maxspeed  = Q_MaxCrouchSpeed;
                }
            }
            else
            {
                friction  = QA_Friction(Q_GroundFriction * dropoffFactor, Q_StopGroundSpeed);
                wishspeed = Q_GroundSpeed;
                maxspeed  = Q_MaxGroundSpeed;
            }
        }
        else
        {
            if (reactiontime <= 0)
            {
                [movedir, movelength] = QA_GetMoveDir(cmd, Angle, Pitch, (Q_FlawedAirMove ? QMF_FLAWEDXY : 0));
            }

            friction  = QA_Friction(Q_AirFriction, Q_StopAirSpeed);
            wishspeed = Q_AirSpeed;
            maxspeed  = Q_MaxAirSpeed;
        }
        
        double speedmult = QA_GetSpeedBoosts() * friction * movelength;
        
        if (waterlevel)
        {
            double waterfriction = QA_HalftimeToFriction(Q_WaterFriction, TICRATE) * (waterlevel / 3.0);
            double halftime      = QA_FrictionToHalftime(waterfriction, TICRATE);
            
            QA_Friction(halftime, Q_StopWaterSpeed);
            speedmult *= Q_WadingSpeedScale;
        }
        
        vector3 accel = QA_Accelerate(movedir, wishspeed * speedmult, maxspeed * speedmult);
        Bob(accel.xy);

        if (!(player.cheats & CF_PREDICTING) && accel.length() > 0) { PlayRunning(); }
    }


    void QA_SetRoll(Usercmd cmd)
    {
        vector2 velxy   = (vel.x, vel.y);

        vector2 forward      = (cos(Angle), sin(Angle));
        double  forwardSpeed = velxy dot forward;

        vector2 side      = velxy - (forward * forwardSpeed);
        double  sideSpeed = side.length();

        if (deltaangle(atan2(forward.y, forward.x), atan2(side.y, side.x)) > 0) { sideSpeed *= -1; }

        double desiredRoll = clamp(sideSpeed / 8, -5, 5);
        double rollDiff = clamp(desiredRoll - Roll, -22.5 / TICRATE, 22.5 / TICRATE);

        A_SetRoll(Roll + rollDiff);
    }
}
