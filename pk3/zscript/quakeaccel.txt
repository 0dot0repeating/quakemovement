// Copyright Â© 2019 ijon <brouzoufman@lavabit.com>
// This work is free. You can redistribute it and/or modify it under the
// terms of the Do What The Fuck You Want To Public License, Version 2,
// as published by Sam Hocevar. See the LICENSE.txt file for more details.


class QuakeAccelPlayer: PlayerPawn
{
    enum QuakeMoveFlags
    {
        QMF_FLYING       = 0x1,
        QMF_FLAWEDXY     = 0x2,
        QMF_IGNOREJUMP   = 0x4,
        QMF_IGNORECROUCH = 0x8,
    };

    const MAXMOVE                = 0x3200;        // purely for scaling the movement commands
    const DEFAULT_FRICTION       = 0.90625;       // default friction, used for scaling our friction
    const DEFAULT_MOVEMULT       = 0.03125;       // default movement speed mult, also used for friction scaling
    const MORE_FRICTION_VELOCITY = 15000.0/65536; // to unfuck the movement scaling on high friction floors
    const MAXSLOPEPITCH          = 45;            // Slopes at or above this pitch won't get jumped up
    // internal vars

    protected bool    Q_Enabled;             // if off, use regular movement
    protected bool    Q_BlockJump;           // set when you jump, cleared when you let go of jump
    protected bool    Q_BlockSlide;          // set when flying, leaving ground with crouch pressed, and on ground when not sliding; cleared when in midair and not holding crouch (or Q_AutoSlide on)
    protected uint    Q_CrouchSlideHeldTime; // how many tics you've held crouch
    protected int     Q_GroundTime;          // positive = tics spent on ground, negative = tics spent off ground
    protected int     Q_FallTime;            // time spent off ground with negative Z velocity
    protected int     Q_WaterTime;           // positive = tics spent with waterlevel > 1, negative = tics spent with waterlevel <= 1
    protected vector3 Q_LastVel;

    // Q_BlockJump is only set if Q_Autohop is off
    // Q_BlockSlide is only set if Q_EasyCrouchSlide is off
    // Q_CrouchSlideHeldTime won't count down in midair if Q_AutoSlide is on
    // Q_FallTime resets when you next leave the ground

    // exposed vars

    bool   Q_UseQuakeAccel;    // self explanatory

    double Q_GroundSpeed;      // how much speed (u/s**2) you gain in
    double Q_CrouchSpeed;      // a second when moving 100% in one direction,
    double Q_AirSpeed;         // ignoring friction and speed caps
    double Q_FlySpeed;
    double Q_WaterSpeed;
    double Q_CSlideSpeed;

    double Q_MaxGroundSpeed;   // acceleration "speed cap" (u/s) - it
    double Q_MaxCrouchSpeed;   // only checks your velocity in the direction
    double Q_MaxAirSpeed;      // you're accelerating, hence strafejumping
    double Q_MaxFlySpeed;      //
    double Q_MaxWaterSpeed;    // max speed values below 0 mean "no speed cap"
    double Q_MaxCSlideSpeed;

    double Q_GroundFriction;   // how many seconds it takes for your velocity to
    double Q_CrouchFriction;   // be reduced to half its current value - engine
    double Q_AirFriction;      // friction is zeroed out to allow for ours
    double Q_FlyFriction;      //
    double Q_WaterFriction;    // friction value below 0 means "no friction"
    double Q_CSlideFriction;

    double Q_StopGroundSpeed;  // if your speed (u/s) is below this value, the
    double Q_StopCrouchSpeed;  // friction formula acts like your speed is this
    double Q_StopAirSpeed;     // when determining how much to lower your velocity
    double Q_StopFlySpeed;
    double Q_StopWaterSpeed;
    double Q_StopCSlideSpeed;

    
    double Q_ForwardScale;     // speed scalar that applies to all movement modes
    double Q_BackwardScale;    // all of these scale your accel and max speed
    double Q_SideScale;
    double Q_UpScale;
    
    double Q_GroundForwardScale;    // all of these stack multiplicatively with
    double Q_GroundBackwardScale;   //  the general speed scalars
    double Q_GroundSideScale;
    double Q_GroundUpScale;

    double Q_AirForwardScale;       // fuck copypasting these btw
    double Q_AirBackwardScale;
    double Q_AirSideScale;
    double Q_AirUpScale;

    double Q_FlyForwardScale;       // aaaaaaaaaaaaaaa
    double Q_FlyBackwardScale;
    double Q_FlySideScale;
    double Q_FlyUpScale;

    double Q_WaterForwardScale;     // AAAAAAAAAAAAAAAAAAAAAA
    double Q_WaterBackwardScale;
    double Q_WaterSideScale;
    double Q_WaterUpScale;

    double Q_CSlideForwardScale;    // let me die
    double Q_CSlideBackwardScale;
    double Q_CSlideSideScale;
    double Q_CSlideUpScale;

    double Q_WadingScale;           // applies when waterlevel = 1

    
    double Q_Gravity;               // gravity value when using quake accel
    double Q_JumpHeight;            // jump height to use when using quake accel
    double Q_MidairStepHeight;      // your MaxStepHeight when in midair
    double Q_DoubleJumpFactor;      // add portion of jump height to Z velocity on jump, rather than just set
    double Q_RampJumpFactor;        // Controls how much a ramp's slope can affect your jump height
    uint   Q_CrouchSlideTime;       // minimum amount of tics you can slide for after hitting the ground
    double Q_CrouchSlideTimeScale;  // your fall time is multiplied by this and added to Q_CrouchSlideTime
    uint   Q_CrouchSlideTimeMax;    // does exactly what it says it does (it's in tics)
    double Q_MagneticLedgeScale;    // scales friction if you're about to walk off a ledge

    bool   Q_EasyCrouchSlide;  // slide time doesn't tick down if you hold crouch in midair
    bool   Q_Autohop;          // you don't need to let go of jump to repeatedly jump
    bool   Q_AutoSlide;        // you don't need to let go of crouch to repeatedly slide
    bool   Q_FlawedAirMove;    // replicate quake 3 behavior where holding jump midair slows horizontal movement
    bool   Q_VQ1Bunnyhop;      // ground friction applies for a tic, even if you hop immediately
    bool   Q_InstantZAdjust;   // when swimming, jump and crouch instantly make you rise/fall at set speeds
    bool   Q_Q2SurfaceTension; // when swimming on the surface (waterlevel 1), Z velocity maxes out at 0

    double Q_RollScale;        // side velocity * rollScale = desired roll angle
    double Q_RollSpeed;        // how many degrees per tic can roll change
    double Q_RollMax;          // clamps desired roll



    property UseQuakeAccel:   Q_UseQuakeAccel;

    // convenience
    property Speeds:          Q_GroundSpeed,     Q_CrouchSpeed,     Q_AirSpeed,     Q_WaterSpeed,     Q_FlySpeed,     Q_CSlideSpeed;
    property MaxSpeeds:       Q_MaxGroundSpeed,  Q_MaxCrouchSpeed,  Q_MaxAirSpeed,  Q_MaxWaterSpeed,  Q_MaxFlySpeed,  Q_MaxCSlideSpeed;
    property Frictions:       Q_GroundFriction,  Q_CrouchFriction,  Q_AirFriction,  Q_WaterFriction,  Q_FlyFriction,  Q_CSlideFriction;
    property StopSpeeds:      Q_StopGroundSpeed, Q_StopCrouchSpeed, Q_StopAirSpeed, Q_StopWaterSpeed, Q_StopFlySpeed, Q_StopCSlideSpeed;
    
    property ForwardScales:   Q_ForwardScale,  Q_GroundForwardScale,  Q_AirForwardScale,  Q_WaterForwardScale,  Q_FlyForwardScale,  Q_CSlideForwardScale;
    property BackwardScales:  Q_BackwardScale, Q_GroundBackwardScale, Q_AirBackwardScale, Q_WaterBackwardScale, Q_FlyBackwardScale, Q_CSlideBackwardScale;
    property SideScales:      Q_SideScale,     Q_GroundSideScale,     Q_AirSideScale,     Q_WaterSideScale,     Q_FlySideScale,     Q_CSlideSideScale;
    property UpScales:        Q_UpScale,       Q_GroundUpScale,       Q_AirUpScale,       Q_WaterUpScale,       Q_FlyUpScale,       Q_CSlideUpScale;

    
    property GroundSpeed:     Q_GroundSpeed;
    property CrouchSpeed:     Q_CrouchSpeed;
    property AirSpeed:        Q_AirSpeed;
    property FlySpeed:        Q_FlySpeed;
    property WaterSpeed:      Q_WaterSpeed;
    property CSlideSpeed:     Q_CSlideSpeed;

    property MaxGroundSpeed:  Q_MaxGroundSpeed;
    property MaxCrouchSpeed:  Q_MaxCrouchSpeed;
    property MaxAirSpeed:     Q_MaxAirSpeed;
    property MaxFlySpeed:     Q_MaxFlySpeed;
    property MaxWaterSpeed:   Q_MaxWaterSpeed;
    property MaxCSlideSpeed:  Q_MaxCSlideSpeed;

    property GroundFriction:  Q_GroundFriction;
    property CrouchFriction:  Q_CrouchFriction;
    property AirFriction:     Q_AirFriction;
    property FlyFriction:     Q_FlyFriction;
    property WaterFriction:   Q_WaterFriction;
    property CSlideFriction:  Q_CSlideFriction;

    property StopGroundSpeed: Q_StopGroundSpeed;
    property StopCrouchSpeed: Q_StopCrouchSpeed;
    property StopAirSpeed:    Q_StopAirSpeed;
    property StopFlySpeed:    Q_StopFlySpeed;
    property StopWaterSpeed:  Q_StopWaterSpeed;
    property StopCSlideSpeed: Q_StopCSlideSpeed;

    
    property ForwardScale:          Q_ForwardScale;         // hello is it time to suffer
    property BackwardScale:         Q_BackwardScale;
    property SideScale:             Q_SideScale;
    property UpScale:               Q_UpScale;
    
    property GroundForwardScale:    Q_GroundForwardScale;   // yes
    property GroundBackwardScale:   Q_GroundBackwardScale;
    property GroundSideScale:       Q_GroundSideScale;
    property GroundUpScale:         Q_GroundUpScale;

    property AirForwardScale:       Q_AirForwardScale;
    property AirBackwardScale:      Q_AirBackwardScale;
    property AirSideScale:          Q_AirSideScale;
    property AirUpScale:            Q_AirUpScale;

    property FlyForwardScale:       Q_FlyForwardScale;
    property FlyBackwardScale:      Q_FlyBackwardScale;
    property FlySideScale:          Q_FlySideScale;
    property FlyUpScale:            Q_FlyUpScale;

    property WaterForwardScale:     Q_WaterForwardScale;
    property WaterBackwardScale:    Q_WaterBackwardScale;
    property WaterSideScale:        Q_WaterSideScale;
    property WaterUpScale:          Q_WaterUpScale;

    property CSlideForwardScale:    Q_CSlideForwardScale;
    property CSlideBackwardScale:   Q_CSlideBackwardScale;
    property CSlideSideScale:       Q_CSlideSideScale;
    property CSlideUpScale:         Q_CSlideUpScale;
    
    property WadingScale:     Q_WadingScale;

    
    property QGravity:              Q_Gravity;
    property QJumpHeight:           Q_JumpHeight;
    property MidairStepHeight:      Q_MidairStepHeight;
    property DoubleJumpFactor:      Q_DoubleJumpFactor;
    property RampJumpFactor:        Q_RampJumpFactor;
    property CrouchSlideTime:       Q_CrouchSlideTime;
    property CrouchSlideTimeScale:  Q_CrouchSlideTimeScale;
    property CrouchSlideTimeMax:    Q_CrouchSlideTimeMax;
    property MagneticLedgeScale:    Q_MagneticLedgeScale;

    property Autohop:          Q_Autohop;
    property AutoSlide:        Q_AutoSlide;
    property VQ1Bunnyhop:      Q_VQ1Bunnyhop;
    property EasyCrouchSlide:  Q_EasyCrouchSlide;
    property FlawedAirMove:    Q_FlawedAirMove;
    property InstantZAdjust:   Q_InstantZAdjust;
    property Q2SurfaceTension: Q_Q2SurfaceTension;

    property RollScale:        Q_RollScale;
    property RollSpeed:        Q_RollSpeed;
    property RollMax:          Q_RollMax;

    Default
    {
        QuakeAccelPlayer.UseQuakeAccel   true;

        // the crouchslide values are based off of quake 4 @ 60 fps
        // if you want slash sliding as of october, double the speed values
        //  (quake 4 is largely locked at 60fps, tho q4max duels run at 90fps)
        //
        // the rest of them are based off of quake 1 @ 77 fps
        //  (quakeworld servers typically run at 77fps)
        //
        // if you're porting values from other games with quake movement, see
        //  QA_QFrictionToHalftime below
        //
        // some quake -> halftime friction values:
        //
        //      60 FPS    72 FPS    77 FPS    85 FPS    125 FPS
        //  1: 0.687355  0.688322  0.688636  0.689062  0.690371
        //  2: 0.340765  0.341737  0.342053  0.342480  0.343794
        //  3: 0.225223  0.226201  0.226518  0.226947  0.228265
        //  4: 0.167444  0.168427  0.168746  0.169177  0.170499
        //  5: 0.132769  0.133758  0.134078  0.134511  0.135838
        //  6: 0.109647  0.110641  0.110963  0.111397  0.112729

        // values come from the first quake game you could use the movement in,
        //  with the exception of water speeds, which are half of quake 1's speeds
        //  to better match regular zdoom swim speeds

        QuakeAccelPlayer.GroundSpeed     4400;  // base accel
        QuakeAccelPlayer.CrouchSpeed     1375;  // 5/16 of base accel (q2)
        QuakeAccelPlayer.AirSpeed        4400;  // same as base accel (q1)
        QuakeAccelPlayer.FlySpeed        3520;  // 4/5  of base accel (q3)
        QuakeAccelPlayer.WaterSpeed      2200;  // 1/2  of base accel (q1, but halved)
        QuakeAccelPlayer.CSlideSpeed     2200;  // 1/2  of base accel (q4)

        QuakeAccelPlayer.MaxGroundSpeed  440;   // base speed
        QuakeAccelPlayer.MaxCrouchSpeed  137.5; // 5/16 of base speed (q2)
        QuakeAccelPlayer.MaxAirSpeed     41.25; // 3/32 of base speed (q1)
        QuakeAccelPlayer.MaxFlySpeed     440;   // same as base speed (q3)
        QuakeAccelPlayer.MaxWaterSpeed   220;   // 1/2  of base speed (q1, but halved)
        QuakeAccelPlayer.MaxCSlideSpeed  220;   // 1/2  of base speed (q4)

        QuakeAccelPlayer.GroundFriction  0.168746; // 4 @ 77fps  (q1)
        QuakeAccelPlayer.CrouchFriction  0.111397; // 6 @ 85fps  (q2)
        QuakeAccelPlayer.AirFriction     -1;
        QuakeAccelPlayer.FlyFriction     0.228265; // 3 @ 125fps (q3)
        QuakeAccelPlayer.WaterFriction   0.168746; // 4 @ 77fps  (q1)
        QuakeAccelPlayer.CSlideFriction  0.687355; // 1 @ 60fps  (q4)

        QuakeAccelPlayer.StopGroundSpeed 137.5; // 5/16 of base speed (all games)
        QuakeAccelPlayer.StopCrouchSpeed 137.5;
        QuakeAccelPlayer.StopAirSpeed    0;
        QuakeAccelPlayer.StopFlySpeed    137.5;
        QuakeAccelPlayer.StopWaterSpeed  0;
        QuakeAccelPlayer.StopCSlideSpeed 137.5;

        QuakeAccelPlayer.ForwardScales   1, 1, 1, 1, 1, 1;
        QuakeAccelPlayer.BackwardScales  1, 1, 1, 1, 1, 1;
        QuakeAccelPlayer.SideScales      1, 1, 1, 1, 1, 1;
        QuakeAccelPlayer.UpScales        1, 1, 1, 1, 1, 1;
        QuakeAccelPlayer.WadingScale     0.666; // for parity with regular doomguy

        QuakeAccelPlayer.QGravity               0.65;
        QuakeAccelPlayer.QJumpHeight            40;
        QuakeAccelPlayer.MidairStepHeight       0;
        QuakeAccelPlayer.DoubleJumpFactor       1;
        QuakeAccelPlayer.RampJumpFactor         0.707;
        QuakeAccelPlayer.CrouchSlideTime        0;
        QuakeAccelPlayer.CrouchSlideTimeScale   0;
        QuakeAccelPlayer.CrouchSlideTimeMax     0;
        QuakeAccelPlayer.MagneticLedgeScale     1.5;

        QuakeAccelPlayer.Autohop           false;
        QuakeAccelPlayer.AutoSlide         false;
        QuakeAccelPlayer.VQ1Bunnyhop       false;
        QuakeAccelPlayer.EasyCrouchSlide   false;
        QuakeAccelPlayer.FlawedAirMove     false;
        QuakeAccelPlayer.InstantZAdjust    true;

        QuakeAccelPlayer.RollScale         0.125;
        QuakeAccelPlayer.RollSpeed         22.5;
        QuakeAccelPlayer.RollMax           5;
    }


    // this is here mostly to remind myself how I got these functions
    //
    // friction: endSpeed = startSpeed * (1 - (qfriction * frametime))  (how quake does it)
    //   or:     endSpeed = startSpeed * (1 - (qfriction / ticrate))
    //
    // so friction = qfriction / ticrate
    //
    // quake's friction values get plugged directly into that, but we use halftimes,
    //  so some math is needed
    //
    // (1 - friction) ** (halftime * ticrate) = 0.5
    //  1 - friction =   0.5 ** (1 / (halftime * ticrate))
    //    - friction =   0.5 ** (1 / (halftime * ticrate))  - 1
    //      friction = -(0.5 ** (1 / (halftime * ticrate))) + 1
    //
    // to get halftime from a friction value and ticrate:
    //
    // (1 - friction) ** (halftime * ticrate) = 0.5     // a ** b = c
    // halftime * ticrate = log[1 - friction](0.5)      // log[a](c) = b
    // halftime = log[1 - friction](0.5) / ticrate


    static clearscope double QA_HalftimeToFriction(double halftime, int fps = 35)
    {
        return -(0.5 ** (1 / (halftime * fps))) + 1;
    }

    static clearscope double QA_FrictionToHalftime(double friction, int fps = 35)
    {
        return log(0.5) / (log(1 - friction) * fps);
    }

    static clearscope double QA_HalftimeToQFriction(double halftime, int fps = 35)
    {
        return QA_HalftimeToFriction(halftime, fps) * fps;
    }

    static clearscope double QA_QFrictionToHalftime(double qfriction, int fps = 35)
    {
        return QA_FrictionToHalftime(qfriction / fps, fps);
    }


    static clearscope double QA_Turbo()
    {
        return CVar.FindCVar("turbo").GetFloat() / 100;
    }


    // j = jumpz, g = gravity, h = jump height
    // j(j+g) / 2g = h
    // j(j+g)      = 2gh
    // j^2 + jg   = 2gh
    //
    // aj^2 + bj - 2gh = 0
    // a = 1, b = g, c = 2gh
    //
    // one quadratic formula later
    // j = (sqrt(g^2 + 8gh) - g) / 2
    //
    // problem is, the base formula seems to grab the height of the jump half
    //  a tic before the peak, which means it's usually wrong, but always
    //  close enough to get the correct JumpZ from it. the formula works when
    //  vz = 0 at the peak of the ingame jump, which is why I can fix the estimate.
    //
    // it probably has to do with doom's physics being based off discrete time
    //  units, rather than being continuous. if I knew how to get it right the
    //  first time, I would.

    static clearscope double QA_HeightToJumpZ(double h, double g = 1)
    {
        double baseEstimate = (sqrt(g**2 + (8*g*h)) - g) / 2;

        // round estimate to previous multiple of g (so vz = 0 at the peak tic),
        //  and figure out how high that gets us
        double estimate  = baseEstimate - (baseEstimate % g);
        double estHeight = estimate * (estimate + g) / (2 * g);

        // get the difference from what we want, divide it by the amount of tics
        //  you spend rising, add it onto the estimate
        double estDiff = (h - estHeight);
        double estTime = ceil(baseEstimate / g);
        estimate += estDiff / estTime;

        return estimate;
    }


    static clearscope vector3 QA_Rotate3D(vector3 vec, double yaw, double pitch)
    {
        // x' =  cos(angle) cos(pitch)x + -sin(angle)y + cos(angle) sin(pitch)z
        // y' =  sin(angle) cos(pitch)x +  cos(angle)y + sin(angle) sin(pitch)z
        // z' =            -sin(pitch)x                +            cos(pitch)z

        vector3 ret;

        ret.x = (vec.x * cos(yaw) * cos(pitch))
              - (vec.y * sin(yaw))
              + (vec.z * cos(yaw) * sin(pitch));

        ret.y = (vec.x * sin(yaw) * cos(pitch))
              + (vec.y * cos(yaw))
              + (vec.z * sin(yaw) * sin(pitch));

        ret.z = -(vec.x * sin(pitch))
              +  (vec.z * cos(pitch));

        return ret;
    }


    static void QA_NormalizeMoveCmd(UserCmd cmd)
    {
        // Make walk speed 50% of run speed even when strafing (or try to, anyway -
        //  there's no way of telling whether an analog stick is walking at <= 100%
        //  or running at <= 60%)

        // Movement commands are left shifted 8 bits before being sent to ZScript
        if (abs(cmd.sidemove) < (uint(0x28 * QA_Turbo()) << 8))
        {
            cmd.sidemove = (cmd.sidemove * 25) / 24;
        }
        else
        {
            cmd.sidemove = (cmd.sidemove * 5) / 4;
        }
        
        cmd.upmove = (cmd.upmove * MAXMOVE) / 0x300;

        // no +strafe/joypad shenanigans for you
        cmd.forwardmove = clamp(cmd.forwardmove, -MAXMOVE, MAXMOVE);
        cmd.sidemove    = clamp(cmd.sidemove,    -MAXMOVE, MAXMOVE);
        cmd.upmove      = clamp(cmd.upmove,      -MAXMOVE, MAXMOVE);
    }


    static clearscope vector3, double QA_GetMoveDir(UserCmd cmd, double angle, double pitch, int flags = 0,
                                        double forwardscale = 1, double backscale = 1, double sidescale = 1, double upscale = 1)
    {
        vector3 forward = (0,0,0);
        vector3 side    = (0,0,0);
        vector3 up      = (0,0,0);

        if (flags & QMF_FLYING)
        {
            forward = QA_Rotate3D((cmd.forwardmove, 0, 0), angle, pitch);
            side    = QA_Rotate3D((0, -cmd.sidemove, 0), angle, pitch);
            up.z    = cmd.upmove;

            if (!(flags & QMF_IGNOREJUMP)   && cmd.buttons & BT_JUMP)   { up.z += MAXMOVE; }
            if (!(flags & QMF_IGNORECROUCH) && cmd.buttons & BT_CROUCH) { up.z -= MAXMOVE; }
            up.z = clamp(up.z, -MAXMOVE, MAXMOVE);
        }
        else
        {
            forward.xy = RotateVector((cmd.forwardmove, 0), angle);
            side.xy    = RotateVector((0, -cmd.sidemove), angle);
            if (flags & QMF_FLAWEDXY) { up.z = cmd.upmove; }
        }
        
        if (cmd.forwardmove < 0) { forwardscale = backscale; }

        double movescale = MAXMOVE * QA_Turbo();
        forward /= movescale;
        side    /= movescale;
        up      /= movescale;
        
        // we can't have the movement command exceed the highest scalar, but
        //  we also don't want straferunning to feel like ass, as it would if
        //  we scaled this stuff after the normalization
        
        double topscalar = max(forwardscale, sidescale, upscale);
        forward *= forwardscale;
        side    *= sidescale;
        up      *= upscale;

        vector3 movedir    = forward + side + up;
        double  movelength = movedir.length();
        if (movelength == 0) { return (0, 0, 0), 0; }

        if (movelength > topscalar)
        {
            double rescale = movelength / topscalar;
            
            forward /= rescale;
            side    /= rescale;
            up      /= rescale;
            
            movelength = topscalar;
        }
        
        // for Q_FlawedXYMove
        if (!(flags & QMF_FLYING)) { up = (0,0,0); }

        // angle/pitch might've changed, so recalc
        movedir    = forward + side + up;
        movelength = movedir.length();
        if (movelength == 0) { return (0, 0, 0), 0; }

        return movedir.unit(), movelength;
    }


    bool QA_CheckDropoff(vector2 movedir = (0,0))
    {
        // if we're standing on a thing, don't even bother, it'll just act weird
        if (pos.z > floorz) { return false; }
        
        // if movedir is nonzero, assume the player wants to drop off ledges in
        //  the direction he's moving
        if (movedir.length() > 0)
        {
            movedir = movedir.unit();   
            if (vel.xy dot movedir > 0) { return false; }
        }

        double thresholdFloorZ = floorz;
        double lowestFloorZ    = floorz;

        if (vel.xy.length() > 0)
        {
            for (int i = 0; i < (radius / 8) + 4; i++)
            {
                FCheckPosition checkResult;
                vector2 newpos = pos.xy + (vel.xy.unit() * 8 * i);
                CheckMove(newpos, PCM_NOACTORS, checkResult);

                double checkZ = checkResult.floorz;

                if (checkZ > floorz + MaxStepHeight) { break; }
                if (checkZ > thresholdFloorZ) { thresholdFloorZ = checkZ; }
                lowestFloorZ = min(lowestFloorZ, checkResult.floorz);
            }
        }

        return lowestFloorZ < (thresholdFloorZ - MaxStepHeight);
    }


    void QA_SetEnabled(bool on)
    {
        // voodoo doll check
        if (!self.player || self.player.mo != self) { return; }

        Q_Enabled         = on;
        Gravity           = on ? Q_Gravity : Default.Gravity;
        JumpZ             = on ? QA_HeightToJumpZ(Q_JumpHeight, Q_Gravity) : Default.JumpZ;
        bNoFriction       = on ? true : Default.bNoFriction;
        bNoFrictionBounce = on ? true : Default.bNoFrictionBounce;

        // to avoid any issues with turning quake accel off in midair
        if (!on) { MaxStepHeight = Default.MaxStepHeight; }
    }


    override void Tick()
    {
        if (Q_Enabled != Q_UseQuakeAccel) { QA_SetEnabled(Q_UseQuakeAccel); }
        Super.Tick();
    }


    void Bob(vector2 addVel)
    {
        player.Vel += addVel;
    }

    void SetBob(vector2 vel)
    {
        player.Vel = vel;
    }

    void ReduceBob(double bobFactor)
    {
        player.Vel *= bobFactor;
    }


    // Override to make (un)crouching faster
    override void CheckCrouch(bool totallyfrozen)
    {
        if (!Q_Enabled) { Super.CheckCrouch(totallyfrozen); return; }

        let player = self.player;
        UserCmd cmd = player.cmd;

        if (CanCrouch() && player.health > 0 && level.IsCrouchingAllowed())
        {
            if (!totallyfrozen)
            {
                int crouchdir = (cmd.buttons & BT_CROUCH) && !(cmd.buttons & BT_JUMP) ? -1 : 1;

                if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
                {
                    CrouchMove(4);
                }
                else if (crouchdir == -1 && player.crouchfactor > 0.5)
                {
                    CrouchMove(-4);
                }
            }
        }
        else
        {
            player.Uncrouch();
        }

        player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
    }


    override void HandleMovement()
    {
        if (!Q_Enabled) { Super.HandleMovement(); return; }

        let player  = self.player;
        UserCmd cmd = player.cmd;

        // [RH] Check for fast turn around
        if (cmd.buttons & BT_TURN180 && !(player.oldbuttons & BT_TURN180))
        {
            player.turnticks = TURN180_TICKS;
        }

        bool wasOnGround = player.onground;
        player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);
        MaxStepHeight = (player.onground || waterlevel > 0) ? Default.MaxStepHeight : Q_MidairStepHeight;

        Q_GroundTime  = player.onground ? max(0, Q_GroundTime) + 1 : min(0, Q_GroundTime) - 1;
        Q_WaterTime   = waterlevel > 1  ? max(0, Q_WaterTime)  + 1 : min(0, Q_WaterTime)  - 1;

        if (Q_GroundTime < 0)
        {
            if (Q_GroundTime == -1) { Q_FallTime = 0; }
            Q_FallTime = vel.z > 0 ? 0 : Q_FallTime + 1;
        }

        QA_NormalizeMoveCmd(cmd);
        if (!(cmd.buttons & BT_JUMP))   { Q_BlockJump  = false; }

        QA_TurnPlayer();

        if (QA_CanFlyMove())
        {
            QA_FlyMove();
        }
        else
        {
            QA_GravityMove();
        }

        QA_SetRoll(cmd);

        if (reactiontime > 0) { reactiontime--; }
        Q_LastVel = vel;
    }


    override void DeathThink()
    {
        Super.DeathThink();

        if (Q_Enabled)
        {
            if (QA_CanFlyMove())
            {
                QA_Friction(Q_FlyFriction, Q_StopFlySpeed);
            }
            else if (player.onground)
            {
                QA_Friction(Q_GroundFriction, Q_StopGroundSpeed);
            }
            else
            {
                QA_Friction(Q_AirFriction, Q_StopAirSpeed);
            }
        }
    }


    bool QA_CanFlyMove()
    {
        return waterlevel || bNoGravity;
    }


    bool QA_IsCrouching(UserCmd cmd)
    {
        if (player.IsTotallyFrozen() || player.crouchfactor == -1) { return false; }
        int crouchdir = (cmd.buttons & BT_CROUCH) && CanCrouch() && level.IsCrouchingAllowed() ? -1 : 1;

        // wants to crouch
        if (crouchdir == -1) { return player.crouchfactor < 1; }

        // wants to uncrouch
        return player.crouchfactor <= 0.5;
    }


    double QA_GetSpeedBoosts()
    {
        double factor = Speed * QA_Turbo();

        if (!player.morphTics)
        {
            for(let it = Inv; it != null; it = it.Inv)
            {
                factor *= it.GetSpeedFactor ();
            }
        }

        return factor;
    }


    void QA_TurnPlayer()
    {
        let player = self.player;
        UserCmd cmd = player.cmd;

        // [RH] 180-degree turn overrides all other yaws
        if (player.turnticks > 0)
        {
            player.turnticks--;
            Angle += (180. / TURN180_TICKS);
        }
        else
        {
            Angle += cmd.yaw * (360./65536.);
        }
    }


    // Returns movement speed multiplier
    double QA_Friction(double halftime, double stopspeed, bool usez = false)
    {
        if (!usez)
        {
            double vz = vel.z;
            vel.z = 0;
            double ret = QA_Friction(halftime, stopspeed, true);
            vel.z = vz;
            return ret;
        }

        double normFriction, normSpeed;

        [normFriction, normSpeed] = GetFriction();

        double frictionMult = (1 - normFriction) / (1 - DEFAULT_FRICTION);
        double speedMult    = normSpeed          / DEFAULT_MOVEMULT;
        double speed        = vel.length();

        if (frictionMult > 1)
        {
            // unfuck the speed multiplier
            if      (speed <= MORE_FRICTION_VELOCITY)     { speedMult *= 8; }
            else if (speed <= MORE_FRICTION_VELOCITY * 2) { speedMult *= 4; }
            else if (speed <= MORE_FRICTION_VELOCITY * 4) { speedMult *= 2; }
        }

        // unfuck water level speed mult bullshit
        if (waterlevel > 0 && !player.onground) { speedMult *= 2; }

        if (halftime == 0) { vel = (0,0,0); }

        if (vel.length() == 0)
        {
            ReduceBob(0);
            PlayIdle();
            return speedMult;
        }

        if (halftime < 0)
        {
            return speedMult;
        }

        double friction = QA_HalftimeToFriction(halftime, TICRATE);

        double baseSpeed  = vel.length() * TICRATE;
        double startSpeed = baseSpeed > stopspeed ? baseSpeed : stopspeed;
        double dropSpeed  = startSpeed * (1 - (friction * frictionMult));

        double diffSpeed  = startSpeed - dropSpeed;
        double endSpeed   = max(0, vel.length() - (diffSpeed / TICRATE));

        if (endSpeed == 0)
        {
            PlayIdle();
            ReduceBob(0);
            vel = (0, 0, 0);
        }
        else
        {
            vector3 newvel = vel.unit() * endSpeed;
            ReduceBob(speed > 0 ? endSpeed / speed : 0);
            vel = newvel;
        }

        return speedMult;
    }


    vector3 QA_Accelerate(vector3 wishdir, double wishspeed, double maxspeed)
    {
        vector3 addVel;

        if (maxspeed < 0)
        {
            addVel = wishdir * (wishspeed / (TICRATE * TICRATE));
        }
        else
        {
            double projSpeed  = vel dot wishdir;
            double deltaSpeed = (maxspeed / TICRATE) - projSpeed;
            if (deltaSpeed <= 0) { return (0, 0, 0); }

            addVel = wishdir * min(wishspeed / (TICRATE * TICRATE), deltaSpeed);
        }

        vel += addVel;
        return addVel;
    }


    // Returns the normal of the floor you're standing on, or (0, 0, 1) in midair
    //  Also returns whether it's ok to jump or not

    vector3, bool QA_CheckIfJumpable(double maxPitch = double.max)
    {
        if (floorsector)
        {
            double fas_floorz;
            Sector fas_sector;

            [fas_floorz, fas_sector] = floorsector.NextLowestFloorAt(pos.x, pos.y, pos.z, FFCF_3DRESTRICT, MaxStepHeight);

            vector3 normal = fas_sector.floorplane.Normal;
            double floorPitch = atan2(normal.xy.length(), normal.z);

            if (pos.z <= fas_floorz)
            {
                return normal, floorPitch < maxPitch;
            }
        }

        return (0, 0, 1), player.onGround;
    }


    bool QA_CheckJump()
    {
        UserCmd cmd = player.cmd;

        if (player.onGround && (cmd.buttons & BT_JUMP) && level.IsJumpingAllowed() && !Q_BlockJump)
        {
            vector3 floornormal;
            bool canjump;

            [floornormal, canjump] = QA_CheckIfJumpable(MAXSLOPEPITCH);
            if (!canjump) { return false; }


            double jumpvelz = (JumpZ * 35) / TICRATE;
            double jumpfac  = 0;

            // [BC] If the player has the high jump power, double his jump velocity.
            // (actually, pick the best factors from all active items.)
            //
            // I would modify this to add the effective jump bonuses together,
            //  but that'd lead to serious jump height sequence breaks
            for (let p = Inv; p != null; p = p.Inv)
            {
                let pp = PowerHighJump(p);

                if (pp)
                {
                    double f = pp.Strength;
                    jumpfac = max(jumpfac, f);
                }
            }

            if (jumpfac > 0) { jumpvelz *= jumpfac; }

            vector3 startVel = vel;
            vector3 rampVel  = startvel;

            // Disgusting hack to get what our Z velocity should be
            // Breaks with teleporters, although I guess you could say it's
            //  kinda like portal jumping
            if (Q_GroundTime <= 1)
            {
                startVel.z = rampVel.z = Q_LastVel.z - GetGravity();
            }

            double speedFromFloor = startVel dot floornormal;
            vector3 fromFloorVel  = floornormal * speedFromFloor;
            vector3 alignedvel    = startVel - fromFloorVel;

            vector3 jumpvector = (0, 0, jumpvelz);

            // Going into floor and bunnyhopping, align jump to floor
            if (Q_GroundTime <= 1 && speedFromFloor < 0)
            {
                jumpvector = floornormal * jumpvelz;
            }

            if (speedFromFloor > 0) { rampVel = alignedvel + (fromFloorVel * Q_DoubleJumpFactor); }
            else                    { rampVel = alignedvel; }

            rampVel += jumpvector;

            // XY changes always apply to ramp jumps, but Z changes can be disabled
            vector3 noRampVel  = (vel.x, vel.y, jumpvelz + max(0, startvel.z * Q_DoubleJumpFactor));
            vector3 noRampDiff = rampVel - noRampVel;

            vector3 newVel  = noRampVel + (noRampDiff * Q_RampJumpFactor);
            vector3 velDiff = newvel - vel;
            Bob(velDiff.xy);
            vel = newVel;

            if (!Q_Autohop) { Q_BlockJump  = true; }
            if (!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }

            return true;
        }

        return false;
    }


    void QA_FlyMove()
    {
        UserCmd cmd = player.cmd;
        vector3 movedir = (0,0,0);
        double  movelength = 0;

        bool swimming  = waterlevel && !(bNoclip && bNoGravity);
        bool surfacing = swimming && waterlevel <= 1 && !bNoGravity;

        if (surfacing)
        {
            QA_GravityMove();

            if (Q_WaterTime == -1 && Q_Q2SurfaceTension)
            {
                vel.z = min(0, vel.z - GetGravity());
            }
            else
            {
                vel.z -= GetGravity();
            }

            return;
        }

        Q_BlockSlide = true;

        if (reactiontime <= 0)
        {
            double fwdscale  = Q_ForwardScale  * (swimming ? Q_WaterForwardScale  : Q_FlyForwardScale);
            double backscale = Q_BackwardScale * (swimming ? Q_WaterBackwardScale : Q_FlyBackwardScale);
            double sidescale = Q_SideScale     * (swimming ? Q_WaterSideScale     : Q_FlySideScale);
            double upscale   = Q_UpScale       * (swimming ? Q_WaterUpScale       : Q_FlyUpScale);
            
            int flags = QMF_FLYING;
            if (swimming & Q_InstantZAdjust) { flags |= QMF_IGNOREJUMP | QMF_IGNORECROUCH; }

            [movedir, movelength] = QA_GetMoveDir(cmd, Angle, Pitch, flags, fwdscale, backscale, sidescale, upscale);
        }

        double speedmult, wishspeed, maxspeed, friction;

        if (swimming)
        {
            double halftime = Q_WaterFriction;

            if (waterlevel < 3)
            {
                double friction = QA_HalftimeToFriction(halftime, TICRATE) * (waterlevel / 3.0);
                halftime = QA_FrictionToHalftime(friction, TICRATE);
            }

            friction  = QA_Friction(halftime, Q_StopWaterSpeed, true);
            wishspeed = Q_WaterSpeed;
            maxspeed  = Q_MaxWaterSpeed;
        }
        else
        {
            friction  = QA_Friction(Q_FlyFriction, Q_StopFlySpeed, true);
            wishspeed = Q_FlySpeed;
            maxspeed  = Q_MaxFlySpeed;
        }

        speedmult = QA_GetSpeedBoosts() * friction * movelength;
        // don't do crouch speed multiplier, it only makes sense on the ground

        vector3 accel = QA_Accelerate(movedir, wishspeed * speedmult, maxspeed * speedmult);
        Bob(accel.xy);

        if (!(player.cheats & CF_PREDICTING) && accel.length() > 0) { PlayRunning(); }

        if (reactiontime <= 0 && swimming && Q_InstantZAdjust)
        {
            int direction = 0;
            if (cmd.buttons & BT_JUMP) { direction++; }
            if (cmd.buttons & BT_CROUCH) { direction--; }

            if (direction)
            {
                double upscale = Q_UpScale * (swimming ? Q_WaterUpScale : Q_FlyUpScale);
                
                vel.z = direction * upscale * (Q_MaxWaterSpeed / (TICRATE * 2));
                PlayRunning();
            }
        }

        // TODO: remove this when/if +DONTSINK gets added
        if (swimming && !(cmd.forwardmove || cmd.sidemove)) { cmd.forwardmove = 1; }
    }


    void QA_GravityMove()
    {
        UserCmd cmd = player.cmd;
        vector3 movedir = (0,0,0);
        double  movelength = 0;

        bool crouching = QA_IsCrouching(cmd);
        bool sliding   = false;

        int slideTimeLimit = Q_CrouchSlideTime + int(Q_FallTime * Q_CrouchSlideTimeScale);
        if (Q_CrouchSlideTimeMax > 0) { slideTimeLimit = min(slideTimeLimit, Q_CrouchSlideTimeMax); }

        if (player.onground)
        {
            if (!crouching || Q_CrouchSlideHeldTime > slideTimeLimit)
            {
                Q_BlockSlide = true;
            }
            else
            {
                sliding = !Q_BlockSlide;
                Q_CrouchSlideHeldTime++;
            }
        }
        else
        {
            if (!crouching) { Q_BlockSlide = false; }
            if (Q_GroundTime == -1 && crouching && !Q_AutoSlide) { Q_BlockSlide = true; }

            if (!crouching || Q_EasyCrouchSlide)
            {
                Q_CrouchSlideHeldTime = 0;
            }
            else
            {
                Q_CrouchSlideHeldTime++;
            }
        }


        double friction, wishspeed, maxspeed;
        bool   jumped = QA_CheckJump();

        if (player.onground && (!jumped || Q_VQ1Bunnyhop))
        {
            if (reactiontime <= 0)
            {
                double fwdscale  = Q_ForwardScale  * (sliding ? Q_CSlideForwardScale  : Q_GroundForwardScale);
                double backscale = Q_BackwardScale * (sliding ? Q_CSlideBackwardScale : Q_GroundBackwardScale);
                double sidescale = Q_SideScale     * (sliding ? Q_CSlideSideScale     : Q_GroundSideScale);
                double upscale   = Q_UpScale       * (sliding ? Q_CSlideUpScale       : Q_GroundUpScale);
                
                [movedir, movelength] = QA_GetMoveDir(cmd, Angle, Pitch, 0, fwdscale, backscale, sidescale, upscale);
            }

            double dropoffFactor = QA_CheckDropoff(movedir.xy) ? 1 + Q_MagneticLedgeScale : 1;
            
            if (crouching)
            {
                if (sliding)
                {
                    friction  = QA_Friction(Q_CSlideFriction / dropoffFactor, Q_StopCSlideSpeed);
                    wishspeed = Q_CSlideSpeed;
                    maxspeed  = Q_MaxCSlideSpeed;
                }
                else
                {
                    friction  = QA_Friction(Q_CrouchFriction / dropoffFactor, Q_StopCrouchSpeed);
                    wishspeed = Q_CrouchSpeed;
                    maxspeed  = Q_MaxCrouchSpeed;
                }
            }
            else
            {
                friction  = QA_Friction(Q_GroundFriction / dropoffFactor, Q_StopGroundSpeed);
                wishspeed = Q_GroundSpeed;
                maxspeed  = Q_MaxGroundSpeed;
            }
        }
        else
        {
            if (reactiontime <= 0)
            {
                double fwdscale  = Q_ForwardScale  * Q_AirForwardScale;
                double backscale = Q_BackwardScale * Q_AirBackwardScale;
                double sidescale = Q_SideScale     * Q_AirSideScale;
                double upscale   = Q_UpScale       * Q_AirUpScale;
                
                int flags = (Q_FlawedAirMove ? QMF_FLAWEDXY : 0);
                [movedir, movelength] = QA_GetMoveDir(cmd, Angle, Pitch, flags, fwdscale, backscale, sidescale, upscale);
            }

            friction  = QA_Friction(Q_AirFriction, Q_StopAirSpeed);
            wishspeed = Q_AirSpeed;
            maxspeed  = Q_MaxAirSpeed;
        }

        double speedmult = QA_GetSpeedBoosts() * friction * movelength;

        if (waterlevel)
        {
            double waterfriction = QA_HalftimeToFriction(Q_WaterFriction, TICRATE) * (waterlevel / 3.0);
            double halftime      = QA_FrictionToHalftime(waterfriction, TICRATE);

            QA_Friction(halftime, Q_StopWaterSpeed);
            speedmult *= Q_WadingScale;
        }

        vector3 accel = QA_Accelerate(movedir, wishspeed * speedmult, maxspeed * speedmult);
        Bob(accel.xy);

        if (!(player.cheats & CF_PREDICTING) && accel.length() > 0) { PlayRunning(); }
    }


    void QA_SetRoll(Usercmd cmd)
    {
        if (Q_RollMax == 0) { return; }

        vector2 forward      = (cos(Angle), sin(Angle));
        double  forwardSpeed = vel.xy dot forward;

        vector2 side      = (cos(Angle-90), sin(Angle-90));
        double  sideSpeed = vel.xy dot side;

        double desiredRoll = clamp(sideSpeed * Q_RollScale, -Q_RollMax, Q_RollMax);
        double rollDiff = clamp(desiredRoll - Roll, -Q_RollSpeed / TICRATE, Q_RollSpeed / TICRATE);

        A_SetRoll(Roll + rollDiff);
    }
}
